<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Total Level Benchmark Results</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js"></script>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  html, body { height: 100%; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: #fff;
    color: #1a1a1a;
    display: flex;
    flex-direction: column;
    height: 100vh;
    padding: 24px 32px;
  }
  .page-header {
    margin-bottom: 4px;
  }
  .page-header h1 {
    font-size: 22px;
    font-weight: 600;
    color: #1a1a1a;
  }
  .page-subtitle {
    font-size: 14px;
    color: #999;
    margin-bottom: 16px;
  }
  .download-btn {
    position: absolute;
    top: 24px;
    right: 32px;
    background: none;
    border: none;
    cursor: pointer;
    color: #999;
    font-size: 18px;
    padding: 4px 8px;
  }
  .download-btn:hover { color: #333; }
  .chart-container {
    flex: 1;
    min-height: 0;
    position: relative;
  }
  .bottom-legend {
    display: flex;
    gap: 24px;
    padding: 16px 0 12px;
    flex-wrap: wrap;
  }
  .legend-item {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 13px;
    color: #555;
    cursor: pointer;
  }
  .legend-item.hidden {
    opacity: 0.35;
  }
  .legend-dot {
    width: 10px;
    height: 10px;
    border-radius: 2px;
    flex-shrink: 0;
  }
  .filter-tabs {
    display: flex;
    gap: 8px;
    padding: 8px 0;
    flex-wrap: wrap;
  }
  .filter-tabs button {
    padding: 8px 20px;
    background: #fff;
    border: 1px solid #ddd;
    border-radius: 8px;
    color: #555;
    cursor: pointer;
    font-size: 13px;
    font-weight: 500;
    transition: all 0.15s;
  }
  .filter-tabs button:hover { border-color: #999; color: #1a1a1a; }
  .filter-tabs button.active {
    background: #1a1a1a;
    border-color: #1a1a1a;
    color: #fff;
  }
  .no-data {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #999;
    font-size: 15px;
  }
  .drop-zone {
    max-width: 500px;
    margin: 0 auto;
    padding: 24px;
    border: 2px dashed #ddd;
    border-radius: 12px;
    text-align: center;
    color: #999;
    font-size: 14px;
    cursor: pointer;
    transition: border-color 0.2s, background 0.2s;
  }
  .drop-zone:hover, .drop-zone.dragover { border-color: #4285f4; background: #f0f6ff; }
  .drop-zone input { display: none; }
  .load-bar {
    display: flex;
    gap: 8px;
    justify-content: center;
    margin-bottom: 12px;
  }
  .load-bar button {
    padding: 8px 18px;
    background: #fff;
    border: 1px solid #ddd;
    border-radius: 8px;
    color: #555;
    cursor: pointer;
    font-size: 13px;
    transition: background 0.2s, border-color 0.2s;
  }
  .load-bar button:hover { background: #f5f5f5; border-color: #999; }

  /* Custom tooltip */
  .custom-tooltip {
    position: absolute;
    pointer-events: none;
    background: #fff;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    padding: 12px 16px;
    font-size: 12px;
    box-shadow: 0 4px 16px rgba(0,0,0,0.1);
    z-index: 100;
    min-width: 180px;
    max-width: 260px;
    transition: opacity 0.1s;
  }
  .custom-tooltip.hidden { opacity: 0; }
  .tooltip-header {
    font-weight: 600;
    font-size: 13px;
    margin-bottom: 4px;
    color: #1a1a1a;
  }
  .tooltip-total {
    font-size: 18px;
    font-weight: 700;
    margin-bottom: 8px;
  }
  .tooltip-time {
    font-size: 11px;
    color: #999;
    margin-bottom: 8px;
  }
  .tooltip-skills {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2px 12px;
  }
  .tooltip-skill {
    display: flex;
    justify-content: space-between;
    font-size: 11px;
    color: #666;
  }
  .tooltip-skill .skill-name { text-transform: capitalize; display: flex; align-items: center; gap: 3px; }
  .tooltip-skill .skill-icon { width: 14px; height: 14px; vertical-align: middle; }
  .tooltip-skill .skill-level { font-weight: 600; color: #1a1a1a; }
  .tooltip-skill.leveled .skill-level { color: #2563eb; }

</style>
</head>
<body>

<div class="page-header">
  <h1>Total level over time</h1>
</div>
<div class="page-subtitle" id="pageSubtitle">RS-Agent Benchmark</div>
<button class="download-btn" onclick="downloadChart()" title="Download as PNG">&#8681;</button>

<div class="chart-container" id="chartContainer" style="display:none">
  <canvas id="mainChart"></canvas>
  <div class="custom-tooltip hidden" id="customTooltip"></div>
</div>

<div class="no-data" id="noData" style="display:none">
  No data available for this time horizon
</div>

<div id="loadSection">
  <div class="load-bar" id="loadBar">
    <button onclick="loadCombinedResults()" id="loadBtn">Load Results</button>
  </div>
  <div class="drop-zone" id="dropZone">
    <p>Drop result JSON files here or click to browse</p>
    <input type="file" id="fileInput" multiple accept=".json">
  </div>
</div>

<div class="bottom-legend" id="bottomLegend"></div>
<div class="filter-tabs" id="horizonTabs"></div>

<script>
const MODEL_CONFIG = {
  'opus':   { displayName: 'Claude Opus 4.6',   color: '#8b7355', order: 1, icon: 'model-icons/anthropic.svg' },
  'sonnet': { displayName: 'Claude Sonnet 4.5',  color: '#e07850', order: 2, icon: 'model-icons/anthropic.svg' },
  'gemini': { displayName: 'Gemini 3 Pro',       color: '#4285f4', order: 3, icon: 'model-icons/gemini.webp' },
  'haiku':  { displayName: 'Claude Haiku 3.5',   color: '#e06090', order: 4, icon: 'model-icons/anthropic.svg' },
  'codex':  { displayName: 'Codex CLI',          color: '#10a37f', order: 5, icon: 'model-icons/openai.png' },
  'glm':    { displayName: 'GLM 5',             color: '#6c5ce7', order: 6 },
};

// Pre-load model icons
const modelIcons = {};
(function preloadIcons() {
  const seen = new Set();
  for (const [key, cfg] of Object.entries(MODEL_CONFIG)) {
    if (cfg.icon && !seen.has(cfg.icon)) {
      seen.add(cfg.icon);
      const img = new Image();
      img.src = cfg.icon;
      modelIcons[cfg.icon] = img;
    }
  }
})();

const HORIZON_LABELS = {
  '5m': '5 min',
  '8m': '8 min',
  '10m': '10 min',
  '1h': '1 hour',
  '3h': '3 hours',
};

let combinedData = {};
let currentHorizon = null;
let mainChart = null;
let hiddenModels = new Set();

// ── Data loading ───────────────────────────────────────────────

async function loadCombinedResults() {
  const btn = document.getElementById('loadBtn');
  btn.textContent = 'Loading...';
  try {
    const resp = await fetch('results/_combined.json');
    if (!resp.ok) throw new Error('Not found');
    combinedData = await resp.json();
    onDataLoaded();
    btn.textContent = 'Loaded';
  } catch (e) {
    const models = Object.keys(MODEL_CONFIG);
    let loaded = 0;
    for (const model of models) {
      try {
        const resp = await fetch(`results/${model}.json`);
        if (!resp.ok) continue;
        const data = await resp.json();
        if (data.runs && data.samples) {
          if (!combinedData[model]) combinedData[model] = {};
          for (const run of data.runs) {
            const hz = run.timeHorizon || 'unknown';
            if (!combinedData[model][hz]) {
              combinedData[model][hz] = {
                jobName: run.jobName,
                finalTotalLevel: run.finalTotalLevel,
                durationSeconds: run.durationSeconds,
                samples: data.samples,
              };
            }
          }
          loaded++;
        }
      } catch {}
    }
    btn.textContent = loaded > 0 ? `Loaded ${loaded}` : 'Failed';
    if (loaded > 0) onDataLoaded();
  }
  setTimeout(() => { btn.textContent = 'Reload'; }, 3000);
}

const dropZone = document.getElementById('dropZone');
const fileInput = document.getElementById('fileInput');
dropZone.addEventListener('click', () => fileInput.click());
dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
dropZone.addEventListener('drop', e => {
  e.preventDefault();
  dropZone.classList.remove('dragover');
  for (const file of e.dataTransfer.files) {
    const reader = new FileReader();
    reader.onload = (ev) => {
      try { handleDroppedFile(file.name, JSON.parse(ev.target.result)); } catch {}
    };
    reader.readAsText(file);
  }
});
fileInput.addEventListener('change', e => {
  for (const file of e.target.files) {
    const reader = new FileReader();
    reader.onload = (ev) => {
      try { handleDroppedFile(file.name, JSON.parse(ev.target.result)); } catch {}
    };
    reader.readAsText(file);
  }
});

function handleDroppedFile(filename, data) {
  const firstKey = Object.keys(data)[0];
  if (firstKey && typeof data[firstKey] === 'object' && !data.samples && !data.runs) {
    combinedData = data; onDataLoaded(); return;
  }
  const model = guessModel(filename);
  if (data.samples) {
    if (!combinedData[model]) combinedData[model] = {};
    combinedData[model]['unknown'] = {
      jobName: filename,
      finalTotalLevel: data.samples[data.samples.length - 1]?.totalLevel || 0,
      durationSeconds: (data.samples[data.samples.length - 1]?.elapsedMs || 0) / 1000,
      samples: data.samples,
    };
    onDataLoaded();
  }
}

function guessModel(filename) {
  const lower = filename.toLowerCase();
  for (const m of Object.keys(MODEL_CONFIG)) { if (lower.includes(m)) return m; }
  return filename.replace('.json', '');
}

// ── UI ─────────────────────────────────────────────────────────

function onDataLoaded() {
  const horizons = new Set();
  for (const modelData of Object.values(combinedData)) {
    for (const hz of Object.keys(modelData)) horizons.add(hz);
  }
  const horizonOrder = ['5m', '8m', '10m', '30m', '1h', '3h', 'unknown'];
  const sortedHorizons = Array.from(horizons).sort((a, b) =>
    horizonOrder.indexOf(a) - horizonOrder.indexOf(b)
  );
  const tabsEl = document.getElementById('horizonTabs');
  tabsEl.innerHTML = '<button data-hz="all" onclick="selectHorizon(\'all\')">All</button>' +
    sortedHorizons.map(hz =>
    `<button data-hz="${hz}" onclick="selectHorizon('${hz}')">${HORIZON_LABELS[hz] || hz}</button>`
  ).join('') + `<button data-hz="best" onclick="selectHorizon('best')">Best Run</button>`;

  if (!currentHorizon || (!horizons.has(currentHorizon) && currentHorizon !== 'all' && currentHorizon !== 'best')) {
    currentHorizon = horizons.has('3h') ? '3h' : (sortedHorizons.length > 0 ? sortedHorizons[sortedHorizons.length - 1] : 'best');
  }
  selectHorizon(currentHorizon);
  document.getElementById('loadSection').style.display = 'none';
}

function selectHorizon(hz) {
  currentHorizon = hz;
  document.querySelectorAll('.filter-tabs button').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.hz === hz);
  });
  renderChart();
}

function getDataForHorizon(hz) {
  const result = {};
  for (const [model, horizons] of Object.entries(combinedData)) {
    if (hz === 'best' || hz === 'all') {
      let best = null;
      for (const [, data] of Object.entries(horizons)) {
        if (!best || (data.finalTotalLevel || 0) > (best.finalTotalLevel || 0)) best = data;
      }
      if (best && best.samples && best.samples.length > 0) result[model] = best;
    } else if (horizons[hz]) {
      result[model] = horizons[hz];
    }
  }
  return result;
}

function renderBottomLegend(sortedEntries) {
  const el = document.getElementById('bottomLegend');
  el.innerHTML = sortedEntries.map(([name]) => {
    const config = MODEL_CONFIG[name] || { displayName: name, color: '#999' };
    const isHidden = hiddenModels.has(name);
    return `<div class="legend-item ${isHidden ? 'hidden' : ''}" onclick="toggleModel('${name}')">
      <div class="legend-dot" style="background:${config.color}"></div>
      <span>${config.displayName}</span>
    </div>`;
  }).join('');
}

function toggleModel(name) {
  if (hiddenModels.has(name)) {
    hiddenModels.delete(name);
  } else {
    hiddenModels.add(name);
  }
  renderChart();
}

function renderChart() {
  const data = getDataForHorizon(currentHorizon);
  const container = document.getElementById('chartContainer');
  const noData = document.getElementById('noData');

  if (Object.keys(data).length === 0) {
    container.style.display = 'none';
    noData.style.display = 'flex';
    document.getElementById('bottomLegend').innerHTML = '';
    return;
  }
  container.style.display = 'block';
  noData.style.display = 'none';

  const sortedEntries = Object.entries(data).sort((a, b) =>
    ((MODEL_CONFIG[a[0]] || {order:99}).order) - ((MODEL_CONFIG[b[0]] || {order:99}).order)
  );

  // Update subtitle
  const subtitle = document.getElementById('pageSubtitle');
  const hzLabel = HORIZON_LABELS[currentHorizon] || currentHorizon;
  if (currentHorizon === 'best' || currentHorizon === 'all') {
    subtitle.textContent = 'Best run per model';
  } else {
    subtitle.textContent = `${hzLabel} benchmark`;
  }

  renderBottomLegend(sortedEntries);
  const chartDatasets = sortedEntries
    .filter(([name]) => !hiddenModels.has(name))
    .map(([name, d]) => {
    const config = MODEL_CONFIG[name] || { displayName: name, color: '#999' };
    const samples = d.samples || [];
    return {
      label: config.displayName,
      modelKey: name,
      data: samples.map(s => ({
        x: s.elapsedMs / 60000,
        y: s.totalLevel,
        skills: s.skills,
      })),
      borderColor: config.color,
      backgroundColor: config.color,
      fill: false,
      stepped: 'after',
      pointRadius: 0,
      pointHoverRadius: 5,
      pointBackgroundColor: config.color,
      borderWidth: 2,
      tension: 0,
    };
  });

  if (mainChart) mainChart.destroy();

  const tooltipEl = document.getElementById('customTooltip');

  mainChart = new Chart(document.getElementById('mainChart'), {
    type: 'line',
    data: { datasets: chartDatasets },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: { mode: 'nearest', intersect: false },
      scales: {
        x: {
          type: 'linear',
          title: {
            display: true,
            text: 'Time (minutes)',
            color: '#999',
            font: { size: 13, weight: '400' },
            padding: { top: 8 },
          },
          ticks: { color: '#aaa', font: { size: 11 } },
          grid: { color: '#f0f0f0', drawTicks: false },
          border: { color: '#e0e0e0' },
          min: 0,
        },
        y: {
          title: {
            display: false,
          },
          ticks: {
            color: '#aaa',
            font: { size: 11 },
            callback: (v) => v,
          },
          grid: { color: '#f0f0f0', drawTicks: false },
          border: { color: '#e0e0e0' },
          min: 0,
        }
      },
      plugins: {
        legend: { display: false },
        tooltip: { enabled: false },
      },
      onHover: (event) => {
        // Handled by external tooltip
      },
    },
    plugins: [{
      id: 'endpointLabels',
      afterDraw(chart) {
        const ctx = chart.ctx;
        chart.data.datasets.forEach((ds, i) => {
          const meta = chart.getDatasetMeta(i);
          if (meta.hidden || ds.data.length === 0) return;
          const lastPoint = meta.data[meta.data.length - 1];
          if (!lastPoint) return;

          const x = lastPoint.x;
          const y = lastPoint.y;
          const color = ds.borderColor;
          const config = MODEL_CONFIG[ds.modelKey] || {};
          const iconImg = config.icon ? modelIcons[config.icon] : null;
          const iconSize = 20;

          ctx.save();

          if (iconImg && iconImg.complete && iconImg.naturalWidth > 0) {
            // Draw white circle background with colored border
            ctx.beginPath();
            ctx.arc(x + 16, y, 14, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.fill();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw the icon image centered in the circle
            ctx.drawImage(iconImg, x + 16 - iconSize / 2, y - iconSize / 2, iconSize, iconSize);
          } else {
            // Fallback: draw letter abbreviation
            ctx.beginPath();
            ctx.arc(x + 16, y, 12, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.fill();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.fillStyle = color;
            ctx.font = 'bold 10px -apple-system, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(getModelAbbr(ds.modelKey), x + 16, y);
          }

          ctx.restore();
        });
      }
    }, {
      id: 'customTooltipPlugin',
      afterEvent(chart, args) {
        const event = args.event;
        if (event.type === 'mouseout') {
          tooltipEl.classList.add('hidden');
          return;
        }
        if (event.type !== 'mousemove') return;

        // Custom nearest-point search using Euclidean distance in pixel space.
        // Chart.js "nearest" with axis:'x' ignores y distance entirely, which
        // causes wrong snapping when sample points are sparse and lines are
        // spread apart vertically.
        const mouseX = event.x;
        const mouseY = event.y;
        let bestDist = Infinity;
        let bestDsIdx = -1;
        let bestPtIdx = -1;

        chart.data.datasets.forEach((ds, dsIdx) => {
          const meta = chart.getDatasetMeta(dsIdx);
          if (meta.hidden) return;
          meta.data.forEach((pt, ptIdx) => {
            const dx = pt.x - mouseX;
            const dy = pt.y - mouseY;
            const dist = dx * dx + dy * dy;
            if (dist < bestDist) {
              bestDist = dist;
              bestDsIdx = dsIdx;
              bestPtIdx = ptIdx;
            }
          });
        });

        // Require cursor within reasonable range (150px)
        if (bestDsIdx < 0 || Math.sqrt(bestDist) > 150) {
          tooltipEl.classList.add('hidden');
          return;
        }

        const ds = chart.data.datasets[bestDsIdx];
        const raw = ds.data[bestPtIdx];
        const point = { element: chart.getDatasetMeta(bestDsIdx).data[bestPtIdx], datasetIndex: bestDsIdx, index: bestPtIdx };
        const config = MODEL_CONFIG[ds.modelKey] || { displayName: ds.label, color: '#999' };

        let html = `<div class="tooltip-header" style="color:${config.color}">${config.displayName}</div>`;
        html += `<div class="tooltip-total" style="color:${config.color}">${raw.y}</div>`;
        html += `<div class="tooltip-time">${raw.x.toFixed(1)} minutes</div>`;

        if (raw.skills) {
          html += '<div class="tooltip-skills">';
          const entries = Object.entries(raw.skills).sort((a, b) => b[1].level - a[1].level);
          for (const [skillName, skillData] of entries) {
            const leveled = skillData.level > 1 ? ' leveled' : '';
            const iconSrc = 'skill-icons/' + skillName.toLowerCase() + '.png';
            html += `<div class="tooltip-skill${leveled}">
              <span class="skill-name"><img class="skill-icon" src="${iconSrc}">${skillName}</span>
              <span class="skill-level">${skillData.level}</span>
            </div>`;
          }
          html += '</div>';
        }

        tooltipEl.innerHTML = html;
        tooltipEl.classList.remove('hidden');

        // Position tooltip
        const chartRect = chart.canvas.getBoundingClientRect();
        const canvasX = point.element.x;
        const canvasY = point.element.y;

        let left = canvasX + 16;
        let top = canvasY - 16;

        // Keep tooltip within bounds
        const ttWidth = tooltipEl.offsetWidth || 220;
        const ttHeight = tooltipEl.offsetHeight || 200;
        if (left + ttWidth > chartRect.width - 20) {
          left = canvasX - ttWidth - 16;
        }
        if (top + ttHeight > chartRect.height - 20) {
          top = chartRect.height - ttHeight - 20;
        }
        if (top < 10) top = 10;

        tooltipEl.style.left = left + 'px';
        tooltipEl.style.top = top + 'px';
      }
    }]
  });
}

function getModelAbbr(key) {
  const abbrs = {
    'opus': 'O',
    'sonnet': 'S',
    'haiku': 'H',
    'gemini': 'G',
    'codex': 'C',
    'glm': 'Z',
  };
  return abbrs[key] || key[0]?.toUpperCase() || '?';
}

function downloadChart() {
  if (!mainChart) return;
  const link = document.createElement('a');
  link.download = 'total-level-benchmark.png';
  link.href = mainChart.canvas.toDataURL('image/png', 1.0);
  link.click();
}

loadCombinedResults();
</script>
</body>
</html>
